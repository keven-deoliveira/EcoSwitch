{"ast":null,"code":"'use strict';\n\nimport { randomBytes } from 'react-native-randombytes';\nexports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = randomBytes;\n\nif (typeof window === 'object') {\n  if (!window.crypto) window.crypto = {};\n\n  if (!window.crypto.getRandomValues) {\n    window.crypto.getRandomValues = function getRandomValues(arr) {\n      var orig = arr;\n\n      if (arr.byteLength != arr.length) {\n        arr = new Uint8Array(arr.buffer);\n      }\n\n      var bytes = randomBytes(arr.length);\n\n      for (var i = 0; i < bytes.length; i++) {\n        arr[i] = bytes[i];\n      }\n\n      return orig;\n    };\n  }\n}\n\nexports.createHash = exports.Hash = require('create-hash');\nexports.createHmac = exports.Hmac = require('create-hmac');\nvar hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(Object.keys(require('browserify-sign/algos')));\n\nexports.getHashes = function () {\n  return hashes;\n};\n\nvar p = require('pbkdf2');\n\nexports.pbkdf2 = p.pbkdf2;\nexports.pbkdf2Sync = p.pbkdf2Sync;\n\nvar aes = require('browserify-cipher');\n\n['Cipher', 'createCipher', 'Cipheriv', 'createCipheriv', 'Decipher', 'createDecipher', 'Decipheriv', 'createDecipheriv', 'getCiphers', 'listCiphers'].forEach(function (key) {\n  exports[key] = aes[key];\n});\n\nvar dh = require('diffie-hellman');\n\n['DiffieHellmanGroup', 'createDiffieHellmanGroup', 'getDiffieHellman', 'createDiffieHellman', 'DiffieHellman'].forEach(function (key) {\n  exports[key] = dh[key];\n});\n\nvar sign = require('browserify-sign');\n\n['createSign', 'Sign', 'createVerify', 'Verify'].forEach(function (key) {\n  exports[key] = sign[key];\n});\nexports.createECDH = require('create-ecdh');\n\nvar publicEncrypt = require('public-encrypt');\n\n['publicEncrypt', 'privateEncrypt', 'publicDecrypt', 'privateDecrypt'].forEach(function (key) {\n  exports[key] = publicEncrypt[key];\n});\n\nvar rf = require('randomfill');\n\nexports.randomFill = rf.randomFill;\nexports.randomFillSync = rf.randomFillSync;\n['createCredentials'].forEach(function (name) {\n  exports[name] = function () {\n    throw new Error(['sorry, ' + name + ' is not implemented yet', 'we accept pull requests', 'https://github.com/crypto-browserify/crypto-browserify'].join('\\n'));\n  };\n});","map":{"version":3,"sources":["C:/Users/Keven/Desktop/EcoSwitch/UserApp/EcoSwitchApp/node_modules/react-native-crypto/index.js"],"names":["randomBytes","exports","rng","pseudoRandomBytes","prng","window","crypto","getRandomValues","arr","orig","byteLength","length","Uint8Array","buffer","bytes","i","createHash","Hash","require","createHmac","Hmac","hashes","concat","Object","keys","getHashes","p","pbkdf2","pbkdf2Sync","aes","forEach","key","dh","sign","createECDH","publicEncrypt","rf","randomFill","randomFillSync","name","Error","join"],"mappings":"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","sourcesContent":["'use strict'\n\nimport { randomBytes } from 'react-native-randombytes'\nexports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = randomBytes\n\n// implement window.getRandomValues(), for packages that rely on it\nif (typeof window === 'object') {\n  if (!window.crypto) window.crypto = {}\n  if (!window.crypto.getRandomValues) {\n    window.crypto.getRandomValues = function getRandomValues (arr) {\n      let orig = arr\n      if (arr.byteLength != arr.length) {\n        // Get access to the underlying raw bytes\n        arr = new Uint8Array(arr.buffer)\n      }\n      const bytes = randomBytes(arr.length)\n      for (var i = 0; i < bytes.length; i++) {\n        arr[i] = bytes[i]\n      }\n\n      return orig\n    }\n  }\n}\n\nexports.createHash = exports.Hash = require('create-hash')\nexports.createHmac = exports.Hmac = require('create-hmac')\n\nvar hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(Object.keys(require('browserify-sign/algos')))\nexports.getHashes = function () {\n  return hashes\n}\n\nvar p = require('pbkdf2')\nexports.pbkdf2 = p.pbkdf2\nexports.pbkdf2Sync = p.pbkdf2Sync\n\nvar aes = require('browserify-cipher')\n;[\n  'Cipher',\n  'createCipher',\n  'Cipheriv',\n  'createCipheriv',\n  'Decipher',\n  'createDecipher',\n  'Decipheriv',\n  'createDecipheriv',\n  'getCiphers',\n  'listCiphers'\n].forEach(function (key) {\n  exports[key] = aes[key]\n})\n\nvar dh = require('diffie-hellman')\n;[\n  'DiffieHellmanGroup',\n  'createDiffieHellmanGroup',\n  'getDiffieHellman',\n  'createDiffieHellman',\n  'DiffieHellman'\n].forEach(function (key) {\n  exports[key] = dh[key]\n})\n\nvar sign = require('browserify-sign')\n;[\n  'createSign',\n  'Sign',\n  'createVerify',\n  'Verify'\n].forEach(function (key) {\n  exports[key] = sign[key]\n})\n\nexports.createECDH = require('create-ecdh')\n\nvar publicEncrypt = require('public-encrypt')\n\n;[\n  'publicEncrypt',\n  'privateEncrypt',\n  'publicDecrypt',\n  'privateDecrypt'\n].forEach(function (key) {\n  exports[key] = publicEncrypt[key]\n})\n\nvar rf = require('randomfill')\n\nexports.randomFill = rf.randomFill\nexports.randomFillSync = rf.randomFillSync\n\n// the least I can do is make error messages for the rest of the node.js/crypto api.\n;[\n  'createCredentials'\n].forEach(function (name) {\n  exports[name] = function () {\n    throw new Error([\n      'sorry, ' + name + ' is not implemented yet',\n      'we accept pull requests',\n      'https://github.com/crypto-browserify/crypto-browserify'\n    ].join('\\n'))\n  }\n})\n"]},"metadata":{},"sourceType":"module"}