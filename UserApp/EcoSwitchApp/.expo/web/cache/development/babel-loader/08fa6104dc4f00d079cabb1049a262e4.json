{"ast":null,"code":"if (typeof Buffer === 'undefined') {\n  global.Buffer = require('buffer').Buffer;\n}\n\nvar sjcl = require('sjcl');\n\nvar RNRandomBytes = require('react-native').NativeModules.RNRandomBytes;\n\nfunction noop() {}\n\nfunction toBuffer(nativeStr) {\n  return new Buffer(nativeStr, 'base64');\n}\n\nfunction init() {\n  if (RNRandomBytes.seed) {\n    var seedBuffer = toBuffer(RNRandomBytes.seed);\n    addEntropy(seedBuffer);\n  } else {\n    seedSJCL();\n  }\n}\n\nfunction addEntropy(entropyBuf) {\n  var hexString = entropyBuf.toString('hex');\n  var stanfordSeed = sjcl.codec.hex.toBits(hexString);\n  sjcl.random.addEntropy(stanfordSeed);\n}\n\nexport function seedSJCL(cb) {\n  cb = cb || noop;\n  randomBytes(4096, function (err, buffer) {\n    if (err) return cb(err);\n    addEntropy(buffer);\n  });\n}\nexport function randomBytes(length, cb) {\n  if (!cb) {\n    var size = length;\n    var wordCount = Math.ceil(size * 0.25);\n\n    var _randomBytes = sjcl.random.randomWords(wordCount, 10);\n\n    var hexString = sjcl.codec.hex.fromBits(_randomBytes);\n    hexString = hexString.substr(0, size * 2);\n    return new Buffer(hexString, 'hex');\n  }\n\n  RNRandomBytes.randomBytes(length, function (err, base64String) {\n    if (err) {\n      cb(err);\n    } else {\n      cb(null, toBuffer(base64String));\n    }\n  });\n}\ninit();","map":{"version":3,"sources":["C:/Users/Keven/Desktop/EcoSwitch/UserApp/EcoSwitchApp/node_modules/react-native-randombytes/index.js"],"names":["Buffer","global","require","sjcl","RNRandomBytes","NativeModules","noop","toBuffer","nativeStr","init","seed","seedBuffer","addEntropy","seedSJCL","entropyBuf","hexString","toString","stanfordSeed","codec","hex","toBits","random","cb","randomBytes","err","buffer","length","size","wordCount","Math","ceil","randomWords","fromBits","substr","base64String"],"mappings":"AAAA,IAAI,OAAOA,MAAP,KAAkB,WAAtB,EAAmC;AACjCC,EAAAA,MAAM,CAACD,MAAP,GAAgBE,OAAO,CAAC,QAAD,CAAP,CAAkBF,MAAlC;AACD;;AAED,IAAIG,IAAI,GAAGD,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIE,aAAa,GAAGF,OAAO,CAAC,cAAD,CAAP,CAAwBG,aAAxB,CAAsCD,aAA1D;;AAEA,SAASE,IAAT,GAAiB,CAAE;;AAEnB,SAASC,QAAT,CAAmBC,SAAnB,EAA8B;AAC5B,SAAO,IAAIR,MAAJ,CAAWQ,SAAX,EAAsB,QAAtB,CAAP;AACD;;AAED,SAASC,IAAT,GAAiB;AACf,MAAIL,aAAa,CAACM,IAAlB,EAAwB;AACtB,QAAIC,UAAU,GAAGJ,QAAQ,CAACH,aAAa,CAACM,IAAf,CAAzB;AACAE,IAAAA,UAAU,CAACD,UAAD,CAAV;AACD,GAHD,MAGO;AACLE,IAAAA,QAAQ;AACT;AACF;;AAED,SAASD,UAAT,CAAqBE,UAArB,EAAiC;AAC/B,MAAIC,SAAS,GAAGD,UAAU,CAACE,QAAX,CAAoB,KAApB,CAAhB;AACA,MAAIC,YAAY,GAAGd,IAAI,CAACe,KAAL,CAAWC,GAAX,CAAeC,MAAf,CAAsBL,SAAtB,CAAnB;AACAZ,EAAAA,IAAI,CAACkB,MAAL,CAAYT,UAAZ,CAAuBK,YAAvB;AACD;;AAED,OAAO,SAASJ,QAAT,CAAmBS,EAAnB,EAAuB;AAC5BA,EAAAA,EAAE,GAAGA,EAAE,IAAIhB,IAAX;AACAiB,EAAAA,WAAW,CAAC,IAAD,EAAO,UAAUC,GAAV,EAAeC,MAAf,EAAuB;AACvC,QAAID,GAAJ,EAAS,OAAOF,EAAE,CAACE,GAAD,CAAT;AAETZ,IAAAA,UAAU,CAACa,MAAD,CAAV;AACD,GAJU,CAAX;AAKD;AAED,OAAO,SAASF,WAAT,CAAsBG,MAAtB,EAA8BJ,EAA9B,EAAkC;AACvC,MAAI,CAACA,EAAL,EAAS;AACP,QAAIK,IAAI,GAAGD,MAAX;AACA,QAAIE,SAAS,GAAGC,IAAI,CAACC,IAAL,CAAUH,IAAI,GAAG,IAAjB,CAAhB;;AACA,QAAIJ,YAAW,GAAGpB,IAAI,CAACkB,MAAL,CAAYU,WAAZ,CAAwBH,SAAxB,EAAmC,EAAnC,CAAlB;;AACA,QAAIb,SAAS,GAAGZ,IAAI,CAACe,KAAL,CAAWC,GAAX,CAAea,QAAf,CAAwBT,YAAxB,CAAhB;AACAR,IAAAA,SAAS,GAAGA,SAAS,CAACkB,MAAV,CAAiB,CAAjB,EAAoBN,IAAI,GAAG,CAA3B,CAAZ;AACA,WAAO,IAAI3B,MAAJ,CAAWe,SAAX,EAAsB,KAAtB,CAAP;AACD;;AAEDX,EAAAA,aAAa,CAACmB,WAAd,CAA0BG,MAA1B,EAAkC,UAASF,GAAT,EAAcU,YAAd,EAA4B;AAC5D,QAAIV,GAAJ,EAAS;AACPF,MAAAA,EAAE,CAACE,GAAD,CAAF;AACD,KAFD,MAEO;AACLF,MAAAA,EAAE,CAAC,IAAD,EAAOf,QAAQ,CAAC2B,YAAD,CAAf,CAAF;AACD;AACF,GAND;AAOD;AAEDzB,IAAI","sourcesContent":["if (typeof Buffer === 'undefined') {\n  global.Buffer = require('buffer').Buffer\n}\n\nlet sjcl = require('sjcl')\nlet RNRandomBytes = require('react-native').NativeModules.RNRandomBytes\n\nfunction noop () {}\n\nfunction toBuffer (nativeStr) {\n  return new Buffer(nativeStr, 'base64')\n}\n\nfunction init () {\n  if (RNRandomBytes.seed) {\n    let seedBuffer = toBuffer(RNRandomBytes.seed)\n    addEntropy(seedBuffer)\n  } else {\n    seedSJCL()\n  }\n}\n\nfunction addEntropy (entropyBuf) {\n  let hexString = entropyBuf.toString('hex')\n  let stanfordSeed = sjcl.codec.hex.toBits(hexString)\n  sjcl.random.addEntropy(stanfordSeed)\n}\n\nexport function seedSJCL (cb) {\n  cb = cb || noop\n  randomBytes(4096, function (err, buffer) {\n    if (err) return cb(err)\n\n    addEntropy(buffer)\n  })\n}\n\nexport function randomBytes (length, cb) {\n  if (!cb) {\n    let size = length\n    let wordCount = Math.ceil(size * 0.25)\n    let randomBytes = sjcl.random.randomWords(wordCount, 10)\n    let hexString = sjcl.codec.hex.fromBits(randomBytes)\n    hexString = hexString.substr(0, size * 2)\n    return new Buffer(hexString, 'hex')\n  }\n\n  RNRandomBytes.randomBytes(length, function(err, base64String) {\n    if (err) {\n      cb(err)\n    } else {\n      cb(null, toBuffer(base64String))\n    }\n  })\n}\n\ninit()\n"]},"metadata":{},"sourceType":"module"}